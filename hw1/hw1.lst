     1                                  %include "../lib.asm"
     2                              <1> StrToInt:
     3 00000000 57                  <1> push edi
     4 00000001 B739                <1> mov bh,'9'
     5 00000003 B330                <1> mov bl,'0'
     6 00000005 56                  <1> push esi ; сохраняем адрес исходной строки
     7 00000006 803E2D              <1> cmp byte[esi], '-'
     8 00000009 7501                <1> jne .prod
     9 0000000B 46                  <1> inc esi ; пропускаем знак минус
    10 0000000C FC                  <1> .prod cld
    11 0000000D 6631FF              <1> xor di,di ; обнуляем будущее число
    12 00000010 AC                  <1> .cycle: lodsb ; загружаем символ (цифру)
    13 00000011 3C0A                <1> cmp al,10 ; если 10, то на конец
    14 00000013 741F                <1> je .Return
    15 00000015 38D8                <1> cmp al,bl ; сравниваем с кодом нуля
    16 00000017 722F                <1> jb .Error ; "ниже" – Ошибка
    17 00000019 38F8                <1> cmp al,bh ; сравниваем с кодом девяти
    18 0000001B 772B                <1> ja .Error ; "выше" – Ошибка
    19 0000001D 2C30                <1> sub al,30h ; получаем цифру из символа
    20 0000001F 6698                <1> cbw ; расширяем до слова
    21 00000021 6650                <1> push ax ; сохраняем в стеке
    22 00000023 66B80A00            <1> mov ax,10 ; заносим 10 в AX
    23 00000027 66F7E7              <1> mul di ; умножаем, результат в DX:AX
    24 0000002A 665F                <1> pop di ; в DI – очередная цифра
    25 0000002C 6601F8              <1> add ax,di
    26 0000002F 6689C7              <1> mov di,ax ; в DI – накопленное число
    27 00000032 EBDC                <1> jmp .cycle
    28 00000034 5E                  <1> .Return: pop esi
    29 00000035 BB00000000          <1> mov ebx,0
    30 0000003A 803E2D              <1> cmp byte[esi],'-'
    31 0000003D 7503                <1> jne .J
    32 0000003F 66F7DF              <1> neg di
    33 00000042 6689F8              <1> .J mov ax,di
    34 00000045 98                  <1> cwde
    35 00000046 EB0B                <1> jmp .R
    36 00000048 5E                  <1> .Error: pop esi
    37 00000049 B800000000          <1> mov eax,0
    38 0000004E BB01000000          <1> mov ebx,1
    39 00000053 5F                  <1> .R pop EDI
    40 00000054 C3                  <1> ret
    41                              <1> 
    42                              <1> 
    43                              <1> 
    44                              <1> IntToStr:
    45 00000055 57                  <1> push edi
    46 00000056 53                  <1> push ebx
    47 00000057 52                  <1> push edx
    48 00000058 51                  <1> push ecx
    49 00000059 56                  <1> push esi
    50 0000005A C60600              <1> mov byte[esi],0 ; на место знака
    51 0000005D 83F800              <1> cmp eax,0
    52 00000060 7D05                <1> jge .l1
    53 00000062 F7D8                <1> neg eax
    54 00000064 C6062D              <1> mov byte[esi],'-'
    55 00000067 C646060A            <1> .l1 mov byte[esi+6],10
    56 0000006B BF05000000          <1> mov edi,5
    57 00000070 66BB0A00            <1> mov bx,10
    58 00000074 6699                <1> .again: cwd ; расширили слово до двойного
    59 00000076 66F7F3              <1> div bx ; делим результат на 10
    60 00000079 80C230              <1> add dl,30h ; получаем из остатка код цифры
    61 0000007C 88143E              <1> mov [esi+edi],DL ; пишем символ в строку
    62 0000007F 4F                  <1> dec edi ; переводим указатель на
    63                              <1> ; предыдущую позицию
    64 00000080 6683F800            <1> cmp ax, 0 ; преобразовали все число?
    65 00000084 75EE                <1> jne .again
    66 00000086 B806000000          <1> mov eax, 6
    67 0000008B 29F9                <1> sub ecx, edi ; длина результата+знак
    68 0000008D 89C8                <1> mov eax,ecx
    69 0000008F 40                  <1> inc eax ; длина результата+знак+0А
    70 00000090 46                  <1> inc esi ; пропускаем знак
    71 00000091 56                  <1> push esi
    72 00000092 8D343E              <1> lea esi,[esi+edi] ; начало символов результата
    73 00000095 5F                  <1> pop edi
    74                              <1> ;rep movsb
    75 00000096 5E                  <1> pop esi
    76 00000097 59                  <1> pop ecx
    77 00000098 5A                  <1> pop edx
    78 00000099 5B                  <1> pop ebx
    79 0000009A 5F                  <1> pop edi
    80 0000009B C3                  <1> ret
     2                                  
     3                                  section .data ; сегмент инициализированных переменных
     4 00000000 456E74657220737472-     enterMsg db "Enter string, len=20:",10
     4 00000009 696E672C206C656E3D-
     4 00000012 32303A0A           
     5                                  lenEnterMsg equ $-enterMsg
     6 00000016 596F75722072657375-     outMsg db "Your result:", 10
     6 0000001F 6C743A0A           
     7                                  lenOutMsg equ $-outMsg
     8                                  
     9                                  section .bss ; сегмент неинициализированных переменных
    10 00000000 <res Ah>                inBuf resb 10 ; буфер для вводимой строки
    11                                  lenIn equ $-inBuf
    12                                  
    13 0000000A <res 15h>               inStr resb 21 ; память под вводимую строку
    14                                  lenInStr equ $-inStr
    15                                  
    16 0000001F ??????????????          outBuf resb 7 ; буфер для вывода количества повторений
    17                                  lenOut equ $-outBuf
    18                                  
    19 00000026 <res 15h>               outStr resb 21 ; длина результата 20 + байт под конец строки
    20                                  lenOutStr equ $-outStr
    21                                  
    22 0000003B ??                      count resb 1 ; количество повторений OP
    23                                  
    24                                  section .text ; сегмент кода
    25                                  global _start
    26                                  _start:
    27                                      ; выводим сообщение о необходимости ввода
    28 0000009C B804000000                  mov eax, 4 ; системная функция 4 (write)
    29 000000A1 BB01000000                  mov ebx, 1 ; дескриптор файла stdout=1
    30 000000A6 B9[00000000]                mov ecx, enterMsg ; адрес выводимой строки
    31 000000AB BA16000000                  mov edx, lenEnterMsg ; длина выводимой строки
    32 000000B0 CD80                        int 80h ; вызов системной функции
    33                                  
    34                                  input:
    35 000000B2 B803000000                  mov eax, 3 ; системная функция 3 (read)
    36 000000B7 BB00000000                  mov ebx, 0 ; дескриптор файла stdin=0
    37 000000BC B9[0A000000]                mov ecx, inStr ; адрес буфера ввода
    38 000000C1 BA15000000                  mov edx, lenInStr ; размер буфера
    39 000000C6 CD80                        int 80h ; вызов системной функции
    40                                  
    41                                  copyStr:
    42 000000C8 FC                          cld ; сброс флага направления
    43 000000C9 8D35[0A000000]              lea ESI, [inStr] ; загрузка адреса источника
    44 000000CF 8D3D[26000000]              lea EDI, [outStr] ; загрузка адреса приемника
    45 000000D5 B915000000                  mov ECX, 21 ; установка счетчика на длину строки
    46 000000DA F3A4                        rep movsb ; копируем строчку
    47                                  
    48                                  process:
    49 000000DC 8D05[26000000]              lea EAX, [outStr] ; адрес начала строки
    50 000000E2 BB15000000                  mov EBX, 21 ; длина строки
    51 000000E7 89C6                        mov ESI, EAX ; адрес строки
    52 000000E9 50                          push EAX ; сохранили адрес в стек
    53                                  
    54                                  check:
    55 000000EA 8B1424                      mov EDX, [ESP] ; достали адрес начала строки из стека
    56 000000ED 29F2                        sub EDX, ESI ; нашли разницу адресов, она отрицательная
    57 000000EF F7DA                        neg EDX ; взяли модуль от разницы адресов
    58 000000F1 89D9                        mov ECX, EBX 
    59 000000F3 29D1                        sub ECX, EDX ; ECX = сколько символов еще не проверили
    60 000000F5 83F902                      cmp ECX, 2 ; сравнение
    61 000000F8 7C2D                        jl output ; если осталось меньше двух симв, то идем на вывод
    62                                  
    63                                  L1: 
    64 000000FA 668B06                      mov AX, WORD[ESI] ; ввели два символа
    65 000000FD 663D4F50                    cmp AX, 'OP' ; сравнили введенные символы и OP
    66 00000101 7403                        je L2 ; если равно, то начинаем обработку
    67 00000103 46                          inc ESI ; сдвинули указатель на один символ
    68 00000104 EBE4                        jmp check
    69                                  
    70                                  L2:
    71 00000106 C60621                      mov BYTE[ESI], '!' ; заменили первый символ на !
    72 00000109 8D7E01                      lea EDI, [ESI+1] ; установили указатель на P
    73 0000010C 83C602                      add ESI, 2 ; перекинули ESI на символ после P
    74 0000010F 8B1424                      mov EDX, [ESP] ; достали адрес начала строки из стека
    75 00000112 29F2                        sub EDX, ESI ; нашли разницу адресов, она отрицательная
    76 00000114 F7DA                        neg EDX ; взяли модуль от разницы адресов
    77 00000116 89D9                        mov ECX, EBX 
    78 00000118 29D1                        sub ECX, EDX ; ECX = длина строки - текущее положение симв. P
    79 0000011A 56                          push ESI ; сохранили ESI в стек
    80 0000011B F3A4                        rep movsb ; выполнили удаление сдвигом
    81 0000011D 5E                          pop ESI ; достали ESi из стека
    82 0000011E 4E                          dec ESI ; поставили указатель на место, где раньше был симв. P
    83 0000011F FE05[3B000000]              inc BYTE[count] ; увеличили счетчик
    84 00000125 EBC3                        jmp check
    85                                      
    86                                  
    87                                  output:
    88 00000127 53                          push EBX ; сохранили значение в стек
    89                                      ; выводим сообщение о выводе результата
    90 00000128 B804000000                  mov eax, 4 ; системная функция 4 (write)
    91 0000012D BB01000000                  mov ebx, 1 ; дескриптор файла stdout=1
    92 00000132 B9[16000000]                mov ecx, outMsg ; адрес выводимой строки
    93 00000137 BA0D000000                  mov edx, lenOutMsg ; длина выводимой строки
    94 0000013C CD80                        int 80h ; вызов системной функции
    95 0000013E 5B                          pop EBX ; выстащили значение из стека
    96                                      
    97                                      
    98 0000013F 2A1D[3B000000]              sub BL, BYTE[count] ; вычислили новую длину строки
    99 00000145 89DA                        mov edx, EBX ; длина выводимой строки
   100 00000147 B804000000                  mov eax, 4 ; системная функция 4 (write)
   101 0000014C BB01000000                  mov ebx, 1 ; дескриптор файла stdout=1
   102 00000151 B9[26000000]                mov ecx, outStr ; адрес выводимой строки
   103 00000156 CD80                        int 80h ; вызов системной функции
   104                                      
   105 00000158 31C0                        xor EAX, EAX ; очистка EAX
   106 0000015A A0[3B000000]                mov AL, BYTE[count] ; выводим количество повторений OP
   107 0000015F BE[1F000000]                mov ESI, outBuf ; адрес выходной строки
   108 00000164 E8ECFEFFFF                  call IntToStr
   109 00000169 B804000000                  mov eax, 4 ; системная функция 4 (write)
   110 0000016E BB01000000                  mov ebx, 1 ; дескриптор файла stdout=1
   111 00000173 B9[1F000000]                mov ecx, outBuf ; адрес выводимой строки
   112 00000178 BA07000000                  mov edx, lenOut ; длина выводимой строки
   113 0000017D CD80                        int 80h ; вызов системной функции
   114                                      
   115                                              
   116                                  exit:
   117 0000017F B801000000                  mov eax, 1 ; системная функция 1 (exit)
   118 00000184 31DB                        xor ebx, ebx ; код возврата 0
   119 00000186 CD80                        int 80h ; вызов системной функции
