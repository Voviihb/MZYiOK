     1                                  %include "../lib.asm"
     1                              <1> StrToInt:
     2 00000000 57                  <1> push edi
     3 00000001 B739                <1> mov bh,'9'
     4 00000003 B330                <1> mov bl,'0'
     5 00000005 56                  <1> push esi ; сохраняем адрес исходной строки
     6 00000006 803E2D              <1> cmp byte[esi], '-'
     7 00000009 7501                <1> jne .prod
     8 0000000B 46                  <1> inc esi ; пропускаем знак минус
     9 0000000C FC                  <1> .prod cld
    10 0000000D 6631FF              <1> xor di,di ; обнуляем будущее число
    11 00000010 AC                  <1> .cycle: lodsb ; загружаем символ (цифру)
    12 00000011 3C0A                <1> cmp al,10 ; если 10, то на конец
    13 00000013 741F                <1> je .Return
    14 00000015 38D8                <1> cmp al,bl ; сравниваем с кодом нуля
    15 00000017 722F                <1> jb .Error ; "ниже" – Ошибка
    16 00000019 38F8                <1> cmp al,bh ; сравниваем с кодом девяти
    17 0000001B 772B                <1> ja .Error ; "выше" – Ошибка
    18 0000001D 2C30                <1> sub al,30h ; получаем цифру из символа
    19 0000001F 6698                <1> cbw ; расширяем до слова
    20 00000021 6650                <1> push ax ; сохраняем в стеке
    21 00000023 66B80A00            <1> mov ax,10 ; заносим 10 в AX
    22 00000027 66F7E7              <1> mul di ; умножаем, результат в DX:AX
    23 0000002A 665F                <1> pop di ; в DI – очередная цифра
    24 0000002C 6601F8              <1> add ax,di
    25 0000002F 6689C7              <1> mov di,ax ; в DI – накопленное число
    26 00000032 EBDC                <1> jmp .cycle
    27 00000034 5E                  <1> .Return: pop esi
    28 00000035 BB00000000          <1> mov ebx,0
    29 0000003A 803E2D              <1> cmp byte[esi],'-'
    30 0000003D 7503                <1> jne .J
    31 0000003F 66F7DF              <1> neg di
    32 00000042 6689F8              <1> .J mov ax,di
    33 00000045 98                  <1> cwde
    34 00000046 EB0B                <1> jmp .R
    35 00000048 5E                  <1> .Error: pop esi
    36 00000049 B800000000          <1> mov eax,0
    37 0000004E BB01000000          <1> mov ebx,1
    38 00000053 5F                  <1> .R pop EDI
    39 00000054 C3                  <1> ret
    40                              <1> 
    41                              <1> 
    42                              <1> 
    43                              <1> IntToStr:
    44 00000055 57                  <1> push edi
    45 00000056 53                  <1> push ebx
    46 00000057 52                  <1> push edx
    47 00000058 51                  <1> push ecx
    48 00000059 56                  <1> push esi
    49 0000005A C60600              <1> mov byte[esi],0 ; на место знака
    50 0000005D 83F800              <1> cmp eax,0
    51 00000060 7D05                <1> jge .l1
    52 00000062 F7D8                <1> neg eax
    53 00000064 C6062D              <1> mov byte[esi],'-'
    54 00000067 C646060A            <1> .l1 mov byte[esi+6],10
    55 0000006B BF05000000          <1> mov edi,5
    56 00000070 66BB0A00            <1> mov bx,10
    57 00000074 6699                <1> .again: cwd ; расширили слово до двойного
    58 00000076 66F7F3              <1> div bx ; делим результат на 10
    59 00000079 80C230              <1> add dl,30h ; получаем из остатка код цифры
    60 0000007C 88143E              <1> mov [esi+edi],DL ; пишем символ в строку
    61 0000007F 4F                  <1> dec edi ; переводим указатель на
    62                              <1> ; предыдущую позицию
    63 00000080 6683F800            <1> cmp ax, 0 ; преобразовали все число?
    64 00000084 75EE                <1> jne .again
    65 00000086 B806000000          <1> mov eax, 6
    66 0000008B 29F9                <1> sub ecx, edi ; длина результата+знак
    67 0000008D 89C8                <1> mov eax,ecx
    68 0000008F 40                  <1> inc eax ; длина результата+знак+0А
    69 00000090 46                  <1> inc esi ; пропускаем знак
    70 00000091 56                  <1> push esi
    71 00000092 8D343E              <1> lea esi,[esi+edi] ; начало символов результата
    72 00000095 5F                  <1> pop edi
    73                              <1> ;rep movsb
    74 00000096 5E                  <1> pop esi
    75 00000097 59                  <1> pop ecx
    76 00000098 5A                  <1> pop edx
    77 00000099 5B                  <1> pop ebx
    78 0000009A 5F                  <1> pop edi
    79 0000009B C3                  <1> ret
     2                                  
     3                                  section .data ; сегмент инициализированных переменных
     4 00000000 456E74657220417272-     enterMsg db "Enter Array by lines:",10
     4 00000009 6179206279206C696E-
     4 00000012 65733A0A           
     5                                  lenEnterMsg equ $-enterMsg
     6                                  
     7 00000016 010000000200000003-     matrix  dd  1, 2, 3, 4, 5, 6,     
     7 0000001F 000000040000000500-
     7 00000028 000006000000       
     8 0000002E 070000000800000009-             dd  7, 8, 9, 10,11,12,
     8 00000037 0000000A0000000B00-
     8 00000040 00000C000000       
     9 00000046 020000000E00000010-             dd  2,14,16,16,17,18,
     9 0000004F 000000100000001100-
     9 00000058 000012000000       
    10 0000005E 130000001400000015-             dd  19,20,21,22,23,24
    10 00000067 000000160000001700-
    10 00000070 000018000000       
    11 00000076 04000000                rows dd 4 ; строки
    12 0000007A 06000000                cols dd 6 ; столбцы
    13                                  
    14                                  section .bss ; сегмент неинициализированных переменных
    15 00000000 <res 0000000A>          inBuf resb 10 ; буфер для вводимой строки
    16                                  lenIn equ $-inBuf
    17                                  
    18 0000000A <res 00000007>          outBuf resb 7
    19                                  lenOut equ $-outBuf
    20                                  
    21 00000011 <res 00000060>          new_matrix resd 24 ; Резервируем место под новую матрицу, 
    22                                                     ; максимум того же размера
    23 00000071 <res 00000004>          new_cols resd 1 ; память под новое количество столбцов
    24                                  
    25                                  
    26                                  section .text ; сегмент кода
    27                                  global _start
    28                                  _start:
    29                                      ; TODO ввод массива 
    30                                      
    31                                  process:
    32 0000009C BF00000000                  mov EDI, 0 ; индекс в строке для новой матрицы
    33 000000A1 B800000000                  mov EAX, 0 ; обнуляем сумму
    34 000000A6 BB00000000                  mov EBX, 0 ; смещение эл. в строке
    35 000000AB B906000000                  mov ECX, 6 ; количество столбцов
    36                                  cycle1:
    37 000000B0 51                          push ECX ; сохраняем счетчик
    38 000000B1 B903000000                  mov ECX, 3 ; количество элементов в столбце - 1
    39 000000B6 8B83[16000000]              mov EAX, [EBX+matrix] ; первый элемент столбца
    40 000000BC BE18000000                  mov ESI, 24 ; смещение второго элемента столбца
    41                                  cycle2:
    42 000000C1 038433[16000000]            add EAX, [EBX+ESI+matrix] ; добавляем к сумме новый эл.
    43 000000C8 83C618                      add ESI, 24 ; переход к следующему эл. в столбце
    44 000000CB E2F4                        loop cycle2 ; цикл по эл-там столбца
    45                                      
    46 000000CD A901000000                  test EAX, 1 ; проверка суммы на четность
    47 000000D2 7423                        jz next_cycle ; если четная, то обрабатываем дальше
    48                                      ; подготовка к копированию столбца
    49 000000D4 31F6                        xor ESI, ESI ; сброс смещения в столбце
    50 000000D6 B904000000                  mov ECX, 4 ; установка счетчика кол-во эл. в столбце
    51                                  copy_loop:
    52 000000DB 8B8433[16000000]            mov EAX, [EBX+ESI+matrix] ; сохраняем элемент
    53 000000E2 898437[11000000]            mov [EDI+ESI+new_matrix], EAX ; копируем в новую матрицу
    54 000000E9 83C618                      add ESI, 24 ; переход к следующему в столбце
    55 000000EC E2ED                        loop copy_loop
    56 000000EE 83C704                      add EDI, 4 ; переход к след. столбцу в новой матрице
    57 000000F1 FF05[71000000]              inc DWORD[new_cols] ; увеличиваем зн. столбцов в новой матрице
    58                                      
    59                                  
    60                                  next_cycle:
    61 000000F7 59                          pop ECX ; восстановили счетчик cycle1
    62 000000F8 83C304                      add EBX, 4 ; переход к след. столбцу
    63 000000FB E2B3                        loop cycle1 ; цикл по самим столбцам
    64                                      
    65                                  exit:
    66 000000FD B801000000                  mov eax, 1 ; системная функция 1 (exit)
    67 00000102 31DB                        xor ebx, ebx ; код возврата 0
    68 00000104 CD80                        int 80h ; вызов системной функции
